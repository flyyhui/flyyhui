---
title: 设计模式 - 创建型原型与建造者模式
date: 2022-03-01 17:36:38
permalink: /design-pattern/prototype-builder/
categories:
  - 设计模式
tags: 
  - 设计模式
---

[[TOC]]



## 原型模式

### 克隆羊案例

现在有一只羊 tom，姓名为：tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊属性完全相同的 10 只羊。

### 传统方式解决克隆羊实例

思路分析（图解）

![image-20220301174437773](D:\软件区\工具区\Typora\图片\image-20220301174437773.png)

Sheep 类代码：

```java
public class Sheep {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        super();
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep [name=" + name + ", age=" + age + ", color=" + color + "]";
    }
}
```

Client 类代码：

```java
public class Client {

    public static void main(String[] args) {
        // 传统的方法
        Sheep sheep = new Sheep("tom", 1, "白色");

        Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        // ...

        System.out.println(sheep);
        System.out.println(sheep2);
        System.out.println(sheep3);
        System.out.println(sheep4);
        System.out.println(sheep5);
        // ...
    }
}
```

### 传统的方式的优缺点

- 优点是比较好理解，简单易操作
- 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低
- 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活

改进的思路分析：Java 中 Object 类是所有类的根类，Object 类提供了一个 `clone()` 方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力，使用 **原型模式**。

### 原型模式基本介绍

- 原型模式（Prototype 模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
- 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
- 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 `对象.clone()`
- 形象的理解：孙大圣拔出猴毛，变出其它孙大圣

### 原型模式原理结构图

![image-20220301174940372](D:\软件区\工具区\Typora\图片\image-20220301174940372.png)

原理结构图说明：

- Prototype：原型类，声明一个克隆自己的接口
- ConcretePrototype：具体的原型类，实现一个克隆自己的操作
- Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）

### 原型模式解决克隆羊实例

使用原型模式改进传统方式，让程序具有更高的效率和扩展性。

Sheep 类：

```java
public class Sheep implements Cloneable {
    private String name;
    private int age;
    private String color;
    private String address = "蒙古羊";
    public Sheep friend; //是对象，克隆是会如何处理

    public Sheep(String name, int age, String color) {
        super();
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }


    @Override
    public String toString() {
        return "Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";
    }

    // 克隆该实例，使用默认的 clone 方法来完成
    @Override
    protected Object clone() {
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return sheep;
    }
}
```

Client 类：

```java
public class Client {

    public static void main(String[] args) {
        System.out.println("原型模式完成对象的创建");
        Sheep sheep = new Sheep("tom", 1, "白色");

        sheep.friend = new Sheep("jack", 2, "黑色");

        Sheep sheep2 = (Sheep) sheep.clone(); // 克隆
        Sheep sheep3 = (Sheep) sheep.clone(); // 克隆
        Sheep sheep4 = (Sheep) sheep.clone(); // 克隆
        Sheep sheep5 = (Sheep) sheep.clone(); // 克隆

        System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());
        System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());
        System.out.println("sheep4 =" + sheep4 + "sheep4.friend=" + sheep4.friend.hashCode());
        System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());
    }

}
```

### Spring 框架的原型模式

Spring 中原型 bean 的创建，就是原型模式。

![image-20220301175359902](D:\软件区\工具区\Typora\图片\image-20220301175359902.png)

### 深入讨论：浅拷贝和深拷贝

> 浅拷贝的介绍

- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象
- 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
- **前面我们克隆羊案例就是浅拷贝**
- 浅拷贝是使用默认的 `clone()` 方法来实现：`sheep = (Sheep) super.clone();`

> 深拷贝基本介绍

- 复制对象的所有基本数据类型的成员变量值
- 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象 \ 可达的所有对象。也就是说，**对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝**
- 深拷贝实现方式 1：重写 `clone` 方法来实现深拷贝
- 深拷贝实现方式 2：通过 **对象序列化** 实现深拷贝（推荐）
- 深拷贝应用实例

- 使用 重写 `clone` 方法实现深拷贝
- 使用序列化来实现深拷贝

DeepCloneableTarget 类

```java
public class DeepCloneableTarget implements Serializable, Cloneable {

    private static final long serialVersionUID = 1L;

    private String cloneName;

    private String cloneClass;

    // 构造器
    public DeepCloneableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    // 因为该类的属性，都是 String , 因此我们这里使用默认的 clone 完成即可
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

DeepProtoType 类

```java
public class DeepProtoType implements Serializable, Cloneable {

    public String name; // String 属性
    public DeepCloneableTarget deepCloneableTarget; // 引用类型

    public DeepProtoType() {
        super();
    }

    // 深拷贝 - 方式 1 使用 clone 方法
    @Override
    protected Object clone() throws CloneNotSupportedException {

        Object deep = null;
        // 这里完成对基本数据类型（属性）和 String 的克隆
        deep = super.clone();
        // 对引用类型的属性，进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType) deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();

        return deepProtoType;
    }

    //深拷贝 - 方式2 通过对象的序列化实现 (推荐)

    public Object deepClone() {

        // 创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;

        try {
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this); // 当前这个对象以对象流的方式输出

            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType) ois.readObject();

            return copyObj;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
            // 关闭流
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (Exception e2) {
                System.out.println(e2.getMessage());
            }
        }
    }
}
```

Client 类

```java
public class Client {

	public static void main(String[] args) throws Exception {
		DeepProtoType p = new DeepProtoType();
		p.name = "宋江";
		p.deepCloneableTarget = new DeepCloneableTarget("大牛", "小牛");
		
		// 方式 1：完成深拷贝
		
		//DeepProtoType p2 = (DeepProtoType) p.clone();
		
		//System.out.println("p.name=" + p.name + "p.deepCloneableTarget=" + p.deepCloneableTarget.hashCode());
		//System.out.println("p2.name=" + p.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());
	
		//方式 2：完成深拷贝
		DeepProtoType p2 = (DeepProtoType) p.deepClone();
		
		System.out.println("p.name=" + p.name + "p.deepCloneableTarget=" + p.deepCloneableTarget.hashCode());
		System.out.println("p2.name=" + p.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());
	}
}
```

### 原型模式的注意事项和细节

- 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
- 不用重新初始化对象，而是动态地获得对象运行时的状态
- 如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码
- 在实现深克隆的时候可能需要比较复杂的代码
- 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 OCP 原则

## 建造者模式

### 盖房案例

- 需要建房子：这一过程为打桩、砌墙、封顶
- 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的

### 传统方式解决盖房案例

思路分析（图解）

![image-20220301194218699](D:\软件区\工具区\Typora\图片\image-20220301194218699.png)

AbstractHouse 类：

```java
public abstract class AbstractHouse {

    //打地基
    public abstract void buildBasic();

    //砌墙
    public abstract void buildWalls();

    //封顶
    public abstract void roofed();

    public void build() {
        buildBasic();
        buildWalls();
        roofed();
    }
}
```

CommonHouse 类

```java
public class CommonHouse extends AbstractHouse {

    @Override
    public void buildBasic() {
        System.out.println(" 普通房子打地基 ");
    }

    @Override
    public void buildWalls() {
        System.out.println(" 普通房子砌墙 ");
    }

    @Override
    public void roofed() {
        System.out.println(" 普通房子封顶 ");
    }
}
```

Client 类

```java
public class Client {

	public static void main(String[] args) {
		CommonHouse commonHouse = new CommonHouse();
		commonHouse.build();
	}
}
```

### 传统方式的问题分析

优点是比较好理解，简单易操作。

设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性增强了。

解决方案：将产品和产品建造过程解耦：**建造者模式**。

### 建造者模式基本介绍

- 建造者模式（Builder Pattern）又叫 **生成器模式**，是一种对象 **构建模式**。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象
- 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节

### 建造者模式的四个角色

- Product（产品角色）：一个具体的产品对象
- Builder（抽象建造者）：创建一个 Product 对象的各个部件指定的接口 / 抽象类
- ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件
- Director（指挥者）：构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程

### 建造者模式原理类图

![image-20220301195606059](D:\软件区\工具区\Typora\图片\image-20220301195606059.png)

### 建造者模式解决盖房案例

- 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式（Builder Pattern）来完成 
- 思路分析图解（类图）

![image-20220301195650273](D:\软件区\工具区\Typora\图片\image-20220301195650273.png)

建造者类以及子类：

```java
public abstract class HouseBuilder {

    protected House house = new House();

    // 将建造的流程写好, 抽象的方法
    public abstract void buildBasic();
    public abstract void buildWalls();
    public abstract void roofed();

    // 建造房子好， 将产品（房子）返回
    public House buildHouse() {
        return house;
    }
}

public class CommonHouse extends HouseBuilder {
    @Override
    public void buildBasic() {
        System.out.println(" 普通房子打地基 5 米 ");
    }
    @Override
    public void buildWalls() {
        System.out.println(" 普通房子砌墙 10cm ");
    }
    @Override
    public void roofed() {
        System.out.println(" 普通房子屋顶 ");
    }
}
public class HighBuilding extends HouseBuilder {
    @Override
    public void buildBasic() {
        System.out.println(" 高楼的打地基 100 米 ");
    }
    @Override
    public void buildWalls() {
        System.out.println(" 高楼的砌墙 20cm ");
    }
    @Override
    public void roofed() {
        System.out.println(" 高楼的透明屋顶 ");
    }
}
```

房子 House 类

```java
public class House {
    private String baise;
    private String wall;
    private String roofed;
    public String getBaise() {
        return baise;
    }
    public void setBaise(String baise) {
        this.baise = baise;
    }
    public String getWall() {
        return wall;
    }
    public void setWall(String wall) {
        this.wall = wall;
    }
    public String getRoofed() {
        return roofed;
    }
    public void setRoofed(String roofed) {
        this.roofed = roofed;
    }
}
```

HouseDirector 类

```java
public class HouseDirector {
    HouseBuilder houseBuilder = null;
    // 构造器传入 houseBuilder
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    // 通过 setter 传入 houseBuilder
    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    // 如何处理建造房子的流程，交给指挥者
    public House constructHouse() {
        houseBuilder.buildBasic();
        houseBuilder.buildWalls();
        houseBuilder.roofed();
        return houseBuilder.buildHouse();
    }
}

```

Client 测试类

```java
public class Client {
    public static void main(String[] args) {

        // 盖普通房子
        CommonHouse commonHouse = new CommonHouse();
        // 准备创建房子的指挥者
        HouseDirector houseDirector = new HouseDirector(commonHouse);

        // 完成盖房子，返回产品(普通房子)
        House house = houseDirector.constructHouse();

        // System.out.println("输出流程");

        System.out.println("--------------------------");
        // 盖高楼
        HighBuilding highBuilding = new HighBuilding();
        // 重置建造者
        houseDirector.setHouseBuilder(highBuilding);
        // 完成盖房子，返回产品(高楼)
        houseDirector.constructHouse();
    }
}
```

### 建造者模式的 JDK 应用

`java.lang.StringBuilder` 使用了建造者模式

![image-20220301201855363](D:\软件区\工具区\Typora\图片\image-20220301201855363.png)

源码中建造者模式角色分析：

- Appendable 接口定义了多个 append 方法(抽象方法)，即 Appendable 为抽象建造者，定义了抽象方法
- AbstractStringBuilder 实现了 `Appendable` 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化
- StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而 StringBuilder 继承了 AbstractStringBuilder

### 建造者模式的注意事项和细节

- 客户端（使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象
- 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
- 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 **开闭原则**
- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式

> 抽象工厂模式 VS 建造者

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。
